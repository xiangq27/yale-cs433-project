{
  "name": "Yale-cs433-project",
  "tagline": "",
  "body": "Link State and Distance Vector Routing\r\nTeaching Fellow: Qiao Xiang, Yuchen Yang\r\nqiao.xiang@cs.yale.edu, yuchen.yang@yale.edu\r\nPart 1\r\nIn this part, you will work in teams to develop basic neighbor discovery capabilities to each node. The goals\r\nof this first part are to become familiar with the ns-3 development environment and understand the skeleton\r\ncode. Before you write any code, make sure you read in detail the code documentation, understand the API\r\nand structure of the relevant parts of the ns-3 code.\r\nAll your code should go inside the cs433 directory and you should not modify other files in the ns-3\r\ndirectory. Your assignment is to modify the file ls-routing-protocol.cc and dv-routing-protocol.cc in order\r\nto support neighbor discovery. Note that you are free to add new packet types to ls-message.cc and dv-\r\nmessage.cc. Feel free to structure your own code, for instance, introduce your own helper files, or have one\r\nneighbor discovery module shared by both LS and DV.\r\nNeighbor Discovery. Your node continuously probes the network at a low rate to discover its immediate\r\nneighbors in the network topology. Again, you devise a solution within these constraints:\r\n• You may add additional packet types, e.g. periodic broadcast “hello” message on all outgoing interfaces\r\nto neighboring nodes to inform them of the nodes presence. For each “hello” message, neighboring\r\nnodes respond with a “hello reply” message with their IP addresses. The TTL of the broadcast message\r\nhas to be set to 1, to avoid flooding the message to entire network.\r\n• Neighbors disappear as well as appear (as specified in the scenario file or via the interactive command\r\nline). You will want to print out the current list of neighbors so you can see who they are, perhaps\r\nonly printing when there is a change.\r\n• As a tip, you will need to use timers to implement continuous, low-rate background activity. Be\r\nvery careful with automated mechanisms, especially when using flooding and broadcast! They should\r\noperate on the timescale of at least tens of seconds (tens of thousands of milliseconds in the API calls!).\r\n• Add the following command to your node: “DUMP NEIGHBORS” to dump a list of all of the neighbors\r\nto which your node believes it is currently connected. Each neighbor entry should include (neighbor\r\nnode number, neighbor IP address, interface). Please see the code documentation for the exact com-\r\nmands.\r\nHint. It is probably simplest to implement these functions in the order they are given above.\r\nPart 2\r\nYour assignment is to extend your node to support efficient routing by implementing two protocols: link-state\r\n(45%) and distance-vector routing (40%). If your implementation works, you will be able to route packets\r\nhop-by-hop through the network, having packets propagate through a path, only involving nodes enroute to\r\nthe destination.\r\nLink-state routing\r\nYour node must implement link-state routing to construct a routing table, and use this routing table to\r\nforward packets towards their destination. You may read more about link-state routing in Section 4.2.3 of\r\n[1]. Note that we are not implementing OSPF, but a different and simpler link-state protocol. The link-state\r\nprotocol generally involves four steps:\r\n1• Neighbor discovery. To determine your current set of neighbors. You will use the neighbor discovery\r\ncode that you built in Part 1.\r\n• Link-state flooding. To tell all nodes about all neighbors. You will have to implement flooding code\r\nthat uses the neighbor table that you build in part 1 to disseminate link-state packets. Your flooding\r\nprotocol should not result in infinite packet loops or unnecessary duplicate packets (i.e. a node should\r\nnot forward a link-state packet it has seen previously, or has seen a more recent one). A key design\r\nchoice is whether to send out a LinkState packet periodically or immediately after the neighbor list\r\nchanges. A key design criterion is to distribute link state information using as few packets as possible,\r\nwhile keeping nodes as up to date as possible.\r\n• Shortest-path calculation using Dijkstra’s algorithm. To build and keep up-to-date a routing table\r\nthat allows you to determine the next-hop to forward a packet towards its destination. The least-cost\r\nroute is the one with the fewest hops.\r\n• Forwarding. To send packets using the next-hops.\r\nSome basic guidelines\r\n• See the details in [1] for a good suggestion on how to implement Dijkstra’s algorithm. The result of this\r\nalgorithm should be a routing table containing the next-hop neighbor to send to for each destination\r\naddress.\r\n• You should forward packets using the next-hop neighbors in your calculated routing table. The excep-\r\ntion is packets sent to the network broadcast address (e.g., for neighbor discovery or sending link state\r\ninformation); these should be flooded. Note that when your node receives a packet, it may perform\r\none of three actions: (1) if the packet is destined for the node, it will “deliver” the packet locally; (2) if\r\nthe packet is destined for another node, it will “route” the packet; (3) if the packet is destined for the\r\nbroadcast address, it will both deliver packet locally, and continue flooding the packet (while avoiding\r\ninfinite loops).\r\n• Add a command to your node: ”DUMP ROUTES” to dump the contents of the routing table. You\r\nmay find this more convenient than logging the entire routing table after every change. Note that\r\nthis command is already in the skeleton code, and you need to find the function that corresponds to\r\nthis command and modify it accordingly. Each routing table entry should contain (destination node\r\nnumber, destination IP address, next hop node number, next hop IP address, interface, cost).\r\nOnce you have completed all of the above, you should be able to ping any other node (by node number) in\r\nthe network, and have a packet travel to that node and back without being unnecessarily flooded throughout\r\nthe network. To see that your protocol is working, we have provided an example test scenario. (Read Section\r\n4 of code documentation for details.) For your own testing purposes, you might want to set up a small ring\r\nnetwork, use ping to test whether you can reach remote nodes, and then break reachability by stopping a\r\nnode on the path so that ping no longer receives a response. Your routing protocol should detect this and\r\nrepair the situation by finding an alternative path. When it does, ping will work again. Congratulations!\r\nYou have a real, working network!\r\nDistance-vector routing\r\nThe second routing protocol you have to implement is the distance-vector routing protocol. Your solution\r\nshould address the count-to-infinity problem by bounding the distance to a maximum of 16 hops. Note that\r\nwe are not implementing the entire RIP protocol, but a simple distance vector routing protocol that consists\r\nof the following four steps:\r\n• Neighbor discovery. You will use the neighbor discovery code that you built in Part 1.\r\n• Distance-vector exchange. Each node periodically sends its distance-vector to all its neighbors.\r\n• Route calculation. Based on the vectors received from each neighbor, each node computes a routing\r\ntable similar to the above link-state protocol.\r\n2• Forwarding. To send packets using the next-hops, similar to the link-state protocol.\r\nFor this protocol, we will leave the actual implementation more open-ended to allow for your creativity.\r\nUse the same command DUMP ROUTES to dump the table of distance vector. The routing table has the\r\nsame format as that of link-state.\r\nGiven a similar network of diameter less than 16, your distance-vector protocol implementation should\r\ncompute next hops with the same shortest path costs as your link-state protocol. Similar to the link-state\r\nprotocol, all your code should go inside the cs433 directory.\r\nPart 3 - Extra Credits\r\nThis part is entirely optional. We recommend that you only start working on extra credits after you have\r\nfinished the regular credits.\r\nHere are some example extra credits that you can implement. For extra credit, you are responsible for\r\nproviding your own test cases and design documents:\r\n• Path vector protocol (5%). Similar to distance vector protocol, except that complete paths are\r\nadvertised. To avoid the count-to-infinity problem, cycles must be explicitly checked.\r\n• Hazy sighted link state (HSLS) (15%). HSLS is another variant of Link State routing for mobile\r\nad-hoc networks. You can search online to read up more on this protocol. To get the full 15% credit,\r\nyou need to demonstrate a working implementation running an actual mobile ad-hoc network (i.e.\r\nreplace our current pt-to-pt network with an ns-3 MANET setup).\r\n• Delay tolerant networking (15%). Implement summary-based epidemic routing protocol. Demon-\r\nstrate actual implementation in a highly disconnected wireless network where nodes are connected to\r\neach other infrequently.\r\n• Metric-based link-state protocol (10%). Instead of computing routes based on fewest hop count,\r\nallow routes to be selected based on link metrics (e.g. lower loss rates, lower latency, higher bandwidth\r\nare all reasonable choices). Your design can and should make use of the facilities defined above (link\r\nstate advertisements). Link metrics should be syntactically generated (either by writing your own\r\ngenerator or modifying the Inet topology generator), which you have to import into our simulator.\r\n• Incremental Djkstra computation (10%). Given a route update, instead of recomputing Djkstra\r\nfrom scratch for all entries, perform incremental recomputation that only updates routes relevant to the\r\nshortest path. To demonstrate working implementation, you need to demonstrate that your simulation\r\ncan run significantly faster for the same network size (while computing the correct routes of course!).\r\n• Your proposal (X%). If you have a cool extension in mind, feel free to contact the teaching fellow to\r\ndiscuss feasibility and points awarded.\r\nSubmission\r\nPlease archive your code, along with a document elaborating your design and all necessary information, as\r\na zipped file, and submit it through ClassV2 website.\r\nAcknowledgment\r\nThis project was part of the “Networked Systems Programming Projects in ns-3” taught in University of\r\nPennsylvania. Interested readers may refer to http://netdb.cis.upenn.edu/cis553projects/ for more\r\ninformation.\r\nReferences\r\n[1] L. L. Peterson and B. S. Davie. Computer networks: a systems approach. Elsevier, 2007.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}